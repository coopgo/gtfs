// The following directive is necessary to make the package coherent:

// +build ignore

// This program generates unmarshall.go. It can be invoked by running
// go generate
package main

import (
	"bytes"
	"go/format"
	"os"
	"reflect"
	"strings"
	"text/template"
	"time"

	"github.com/coopgo/gtfs"
)

func main() {
	items := []interface{}{
		gtfs.AgencySerializable{},
		gtfs.StopSerializable{},
		gtfs.RouteSerializable{},
		gtfs.TripSerializable{},
		gtfs.StopTimeSerializable{},
		// gtfs.CalendarSerializable{}, // We do not generate since there is a
		// special mapping.
		gtfs.CalendarDateSerializable{},
		gtfs.FareAttributeSerializable{},
		gtfs.FareRuleSerializable{},
		gtfs.ShapeSerializable{},
		gtfs.FrequencySerializable{},
		gtfs.TransferSerializable{},
		gtfs.PathwaySerializable{},
		gtfs.LevelSerializable{},
		gtfs.FeedInfoSerializable{},
		gtfs.TranslationSerializable{},
		gtfs.AttributionSerializable{},
	}

	output, err := gen(items)
	if err != nil {
		panic(err)
	}

	filename := "unmarshal.go"

	f, err := os.Create(filename)
	if err != nil {
		panic(err)
	}
	defer f.Close()

	if _, err := f.Write(output); err != nil {
		panic(err)
	}

}

func gen(item interface{}) ([]byte, error) {
	items := make([]interface{}, 1)
	switch x := item.(type) {
	case []interface{}:
		return generateUnmarshal(x)
	default:
		items[0] = x
		return generateUnmarshal(items)
	}
}

func generateUnmarshal(item []interface{}) ([]byte, error) {
	d := NewData(item)
	d.URL = "coopgo.fr"
	d.Timestamp = time.Now()
	t, err := template.New("").Parse(templ)
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	if err := t.Execute(&buf, d); err != nil {
		return nil, err
	}

	b, err := format.Source(buf.Bytes())
	if err != nil {
		return buf.Bytes(), err
	}

	return b, err
}

type Data struct {
	Data      []Struct
	Timestamp time.Time
	URL       string
}

type Struct struct {
	Struct string
	Fields []Field
}

type Field struct {
	Tag      string
	Type     string
	Name     string
	Required bool
	Empty    Empty
}

type Empty struct {
	Is    bool
	Value string
}

func NewData(items []interface{}) Data {
	data := Data{
		Data: make([]Struct, len(items)),
	}

	for i, item := range items {
		var d Struct
		s := reflect.TypeOf(item)
		d.Struct = s.Name()
		d.Fields = make([]Field, s.NumField())

		for i := 0; i < s.NumField(); i++ {
			field := s.Field(i)
			tag, required, empty := getTag(field.Tag.Get("gtfs"))
			f := Field{
				Tag:      tag,
				Required: required,
				Name:     field.Name,
				Type:     field.Type.Name(),
				Empty:    empty,
			}

			d.Fields[i] = f
		}
		data.Data[i] = d
	}

	return data
}

func getTag(str string) (string, bool, Empty) {
	tags := strings.Split(str, ",")
	if len(tags) == 0 {
		return "", false, Empty{}
	} else if len(tags) == 1 {
		return tags[0], false, Empty{}
	} else if len(tags) == 2 {
		return tags[0], tags[1] == "required", Empty{}
	} else {
		return tags[0], tags[1] == "required", Empty{
			Is:    true,
			Value: tags[2],
		}
	}
}

var templ = `
// Code generated by go generate; DO NOT EDIT.
// This file was generated by robots at
// {{ .Timestamp }}

package gtfs

import "errors"

{{range .Data}}

// ************************************************************************** //
// {{.Struct}} GENERATED CODE
//
// Generated init and unmarshal function for {{.Struct}} struct
// These functions sould be used to do a mapping between a slice of string
// and this struct. 
// ************************************************************************** //

// init initalizes the values which have a gtfs empty value different from the 
// golang zero value or if it's type is a custom one (for example Date).
func (item *{{.Struct}}) init() { 
	{{range .Fields}}
		{{if eq .Type "Time"}}item.{{.Name}} = TimeEmpty
		{{- else if eq .Type "Date"}}item.{{.Name}} = DateEmpty{{end}}
		{{- if .Empty.Is}}item.{{.Name}} = {{.Empty.Value}}{{end}}{{end}}
}

// unmarshal takes a header slice which contains the gtfs tag of the field and a
// slice with contains the values of these fields.
// unmarshal makes the conversion of the d values in the correct type and check 
// the presence of required fields (not conditionnal required fields).
func (item *{{.Struct}}) unmarshal(h []string, d []string) error {
	var err error

	if len(h) != len(d) {
		return errors.New("header diff data")
	}

	item.init()

	for i := 0; i < len(h); i++ {
		switch h[i] {
		{{range .Fields -}} 
		case "{{.Tag}}":
			item.{{.Name}}, err = 	{{- if eq .Type "string" -}}getString(d[i], {{.Required}}) 
								  	{{- else if eq .Type "int"}}getInt(d[i], {{.Required}}, {{if .Empty.Is}}{{.Empty.Value}}{{else}}0{{end}}) 
								  	{{- else if eq .Type "float64"}}getFloat(d[i], {{.Required}}, {{if .Empty.Is}}{{.Empty.Value}}{{else}}0{{end}}) 
									{{- else if eq .Type "Date"}}getDate(d[i], {{.Required}}) 
									{{- else if eq .Type "Time"}}getTime(d[i], {{.Required}}){{end}} 
		{{end}}
		}

		if err != nil {
			return err
		}
	}
	return err
}

{{end}}
`
